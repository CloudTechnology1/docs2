---
title: 'Interacting with zkApps Server-Side'
hide_title: true
sidebar_label: 'Interacting with zkApps Server-Side'
---

:::info

zkApp programmability is not yet available on the Mina Mainnet, but zkApps can now be deployed on Berkeley Testnet.

:::

# Interacting with zkApps server-side

While user-facing zkApps can be written for the browser, sometimes it is useful to interact with a zkApp server-side or from a developer's machine. For example, when initializing a zkApp using programmatically generated information, deploying a zkApp in custom ways, or writing scripts that create transactions depending on real-world or on-chain events.

## Prerequisites

Ensure your environment meets the [Prerequisites](/zkapps/tutorials#prerequisites) for zkApp Developer Tutorials.

Deploy a smart contract. Read and complete [Tutorial 3: Deploy to a Live Network](deploying-to-a-network) that reuses the smart contract `Square` from [Tutorial 1: Hello World](hello-world).

This tutorial has been tested with:

- [Mina zkApp CLI](https://github.com/o1-labs/zkapp-cli) version 0.13.0
- [o1js](https://www.npmjs.com/package/o1js) version 0.13.1

## Interact with the deployed smart contract

Now that you successfully created and deployed your project following [Tutorial 3: Deploy to a Live Network](deploying-to-a-network), you can write a script to interact with the smart contract.

### Building on Tutorial 3

For this tutorial, you update the smart contract that you already built for [Tutorial 3: Deploy to a Live Network](deploying-to-a-network). 

You run commands from the root of the `03-deploying-to-a-live-network` directory as you work in the `src` directory on files that contain the TypeScript code for the smart contract. 

Each time you make updates, then build or deploy, the TypeScript code is compiled into JavaScript in the `build` directory.

### Helper functions in utils.ts

To make this more script convenient to write, use the provided helper functions.

1. Download the [utils.ts](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/interacting-with-zkApps-server-side/src/utils.ts) file. 

1. Place the file in the project `03-deploying-to-a-live-network/src` folder. 

1. Read through the code to understand what it is doing to implement its functionality.

  The `utils.ts` file contains two functions:

  - `loopUntilAccountExists()` waits until an account exists on Berkeley
  - `deploy()` programmatically deploys your zkApp

### Connect to a remote network

1. Download the [main.ts](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/interacting-with-zkApps-server-side/src/main.ts) example file.

1. Because you are building on your earlier work, place the file in the project `03-deploying-to-a-live-network/src` folder. 

1. Review the code that adds the imports and o1js setup:

  ```ts
  import { Square } from './Square.js';
  import { isReady, shutdown, Mina, PrivateKey } from 'o1js';

  import fs from 'fs';
  import { loopUntilAccountExists, deploy } from './utils.js';

  await isReady;

  console.log('o1js loaded');
  ```

1. Now, set the active instance to the remote Berkeley network. Earlier tutorials set the active instance to a local blockchain, which is fast for development but only available on one's local machine and not decentralized.

  The connection is through a GraphQL proxy that runs a Mina node connected to the Berkeley network. By connecting to the remote Berkeley network, you can provide smart contracts that are globally accessible and provide strong guarantees around state due to both Mina's decentralization and its succinct state proof.

  Review the code that connects to Berkeley:

  ```ts
  ...
  // ----------------------------------------------------

  const Berkeley = Mina.Network(
    'https://proxy.berkeley.minaexplorer.com/graphql'
  );
  Mina.setActiveInstance(Berkeley);
  ```

1. Set a transaction fee that you use to pay for access to sending transactions and deploying smart contracts on Mina. 

  Transaction fees in code are declared as nanomina. Review the code that sets the default transaction fee to 0.1 MINA (100,000,000 nanomina):

  ```ts
  ...
  const transactionFee = 100_000_000;
  ...
  ```

This example connects to a remote RPC run by `minaexplorer.com`. You could also run a Mina node locally and instead use its GraphQL endpoint. In other blockchains a local Mina node would be very heavyweight, but because Mina is succinct this is actually a reasonable option. See the Node Operator [Getting Started](/node-operators/getting-started) docs.

### Public/private key pair

You already generated a public/private key pair when you ran the `zk config` command to configure the deployment in [Tutorial 3: Deploy to a Live Network](/zkapps/tutorials/deploying-to-a-network#deploy-alias) the `zk config` command.

The public/private key pair was created in `keys/berkeley.json`. Public and private keys in Mina are commonly stored in Base58 for easily readability. In Mina, public keys start with `B62` and private keys start with `EKE` for easy differentiability.

1. Still in the `main.ts` file, review the code that specifies that the name of the key file must be provided through an argument on the command line: (`process.argv[2]`):

  ```ts
  ...
  const transactionFee = 100_000_000;

  const deployAlias = process.argv[2];
  const deployerKeysFileContents = fs.readFileSync(
    'keys/' + deployAlias + '.json',
    'utf8'
  );
  const deployerPrivateKeyBase58 = JSON.parse(
    deployerKeysFileContents
  ).privateKey;
  const deployerPrivateKey = PrivateKey.fromBase58(deployerPrivateKeyBase58);
  const deployerPublicKey = deployerPrivateKey.toPublicKey();

  const zkAppPrivateKey = PrivateKey.fromBase58(
    'EKFTMuvTirzrwpeHP8RKe7bGufBGiKs27nTMzD5XyMV8NcK3upt2'
  );
  ...
  ```

You can run this now with:

```sh
$ npm run build && node build/src/main.js berkeley
```

This reads keys from `keys/berkeley.json`. Public and private keys in Mina are commonly stored in `base58` for easily readability. In Mina, public keys start with `B62`, and private keys start with `EKE` for easy differentiability.

The SmartContract is also deployed to the same account we deployed from. So we set `zkAppPrivateKey = deployerPrivateKey`. Depending on the application, it can also be useful to have separate keys for the zkApp and deployer accounts!

### Waiting for accounts to be ready

Next, wait for the deployer account to be ready.

In `main.ts`, import and use the `loopUntilAccountExists()` function from `utils.ts`:

```ts
...
  4 import fs from 'fs';
  5 import { loopUntilAccountExists } from './utils.js';
  6
...
 33 // ----------------------------------------------------
 34
 35 let account = await loopUntilAccountExists({
 36   account: deployerPublicKey,
 37   eachTimeNotExist: () => {
 38     console.log(
 39       'Deployer account does not exist. ' +
 40         'Request funds at faucet ' +
 41         'https://faucet.minaprotocol.com/?address=' +
 42         deployerPublicKey.toBase58()
 43     );
 44   },
 45   isZkAppAccount: false,
 46 });
 47
 48 console.log(
 49   `Using fee payer account with nonce ${account.nonce}, balance ${account.balance}`
 50 );
 51
 52 // ----------------------------------------------------
...
```

Wait until the new deployment account exists. If it doesn't, share a link with the user to go to the faucet and request funds.

If the key created from the `zk deploy` command earlier in this tutorial has already been funded, then find the account and move on. If that transaction hasn't finished yet, then wait until that has completed.

After the account is found, print out its nonce and its balance.

Moving on, compile the smart contract and wait for it to have been deployed:

```ts
...
 52 // ----------------------------------------------------
 53
 54 console.log('Compiling smart contract...');
 55 let { verificationKey } = await Square.compile();
 56
 57 const zkAppPublicKey = zkAppPrivateKey.toPublicKey();
 58 let zkapp = new Square(zkAppPublicKey);
 59
 60 // Programmatic deploy:
 61 //   Besides the CLI, you can also create accounts programmatically. This is useful if you need
 62 //   more custom account creation - say deploying a zkApp to a different key than the deployer
 63 //   key, programmatically parameterizing a zkApp before initializing it, or creating Smart
 64 //   Contracts programmatically for users as part of an application.
 65 // await deploy(deployerPrivateKey, zkAppPrivateKey, zkapp, verificationKey);
 66
 67 await loopUntilAccountExists({
 68   account: zkAppPublicKey,
 69   eachTimeNotExist: () =>
 70     console.log('waiting for zkApp account to be deployed...'),
 71   isZkAppAccount: true
 72 });
 73
 74 let num = (await zkapp.num.fetch())!;
 75 console.log(`current value of num is ${num}`);
 76
 77 // ----------------------------------------------------
...
```

To do this, reuse the helper function `loopUntilAccountExists()` from `utils.js`. This time, pass in `isZkappAccount: true` checks if the account exists and that there is a verification key on the account. An existing verification key indicates that the zkApp has been successfully deployed.

The smart contract was already deployed with `zk deploy` so a programmatic deploy is not required and is commented out here. If you want to see how this works, or it's useful for your application, see the code in [utils.ts](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/interacting-with-zkApps-server-side/src/utils.ts).

After being certain that the zkApp has been deployed, fetch the current value of `zkapp.num` (the on-chain defined on the `SmartContract`) and log it. If this is the first time you run this script, the value should be `3` because that's how it is set in the smart contract's `init()` function. The `init()` function is called automatically during the first deploy (not during re-deploys).

<!-- note: I'm commenting this out since setting `provedState` with `init()` doesn't work yet anyway because of the missing verification key protocol bug.

:::info

There is a `provedState` property on accounts present in the protocol, but yet to be exposed in o1js, that can be used to assert in a proof that the smart contract has been initialized.

This `provedState` property starts out `false` when a contract is deployed. It is set to true whenever the _entire state_ of the smart contract is overwritten by a proof. TODO. More details will be released as this feature is made available.

::: -->

### Calling update on our transaction

Finally, send an update to the transaction. If the zkApp was just initialized, this calls an update on the newly initialized account. Otherwise, it calls an update on whatever the current account state happens to be.

```ts
...
 77 // ----------------------------------------------------
 78
 79 let transaction = await Mina.transaction(
 80   { sender: deployerPublicKey, fee: transactionFee },
 81   () => {
 82     zkapp.update(num.mul(num));
 83   }
 84 );
 85
 86 // fill in the proof - this can take a while...
 87 console.log('Creating an execution proof...');
 88 let time0 = performance.now();
 89 await transaction.prove();
 90 let time1 = performance.now();
 91 console.log(`creating proof took ${(time1 - time0) / 1e3} seconds`);
 92
 93 // sign transaction with the deployer account
 94 transaction.sign([deployerPrivateKey]);
 95
 96 console.log('Sending the transaction...');
 97 let pendingTransaction = await transaction.send();
 98
 99 // ----------------------------------------------------
...
```

To send an update transaction, perform the following steps:

1. Construct the transaction with `Mina.transaction`. This is where you call `zkapp.update()`, the custom method defined on the smart contract.
2. Create a proof of the transaction. This can take up to a minute.
3. Sign the transaction, and send it to the network.

When sending the transaction using `transaction.send()`, an object called `pendingTransaction` is returned and provides information about how the transaction went and waits for inclusion in a block:

```ts
 99 // ----------------------------------------------------
100
101 if (!pendingTransaction.isSuccess) {
102   console.log('error sending transaction (see above)');
103   process.exit(0);
104 }
105
106 console.log(
107   `See transaction at https://berkeley.minaexplorer.com/transaction/${pendingTransaction.hash()}
108 Waiting for transaction to be included...`
109 );
110 await pendingTransaction.wait();
111
112 console.log(`updated state! ${await zkapp.num.fetch()}`);
113
114 // ----------------------------------------------------
```

Here you use several functionalities of the pending transaction:

- `pendingTransaction.isSuccess` is a boolean for whether the transaction was successful. Most invalid transactions are immediately rejected by the GraphQL endpoint immediately with `isSuccess === false`.
- `pendingTransaction.hash()` is the transaction hash that you can use to look up the transaction in a block explorer. If the transaction failed, returns `undefined`.
- `pendingTransaction.wait()` is especially useful as it returns a promise that resolves utils.ts after the transaction is included in the latest block on the network. This takes several minutes, so you might not want to block the main thread on this in a real application.

Finally, after the transaction was successfully applied on the Mina blockchain, you can double-check that your state was updated by fetching it again with `zkapp.num.fetch()`.

## Conclusion

You have finished writing a script to initialize the state and interact with it! You can also run this script multiple times to update `x` to its square.

Check out other tutorials and documentation to keep going!
